@using System.Linq
@using System.Reflection
@namespace CGA
@accessibility public
@classname Parser
@members {
	private static T ParseEnum<T>(string value) where T : struct, IConvertible
	{
		if (!typeof(T).IsEnum) 
		{
			throw new ArgumentException($"{typeof(T).FullName} is not an enumerator");
		}
		return (T)Enum.Parse(typeof(T), value.ToUpper()); 
	}
}

R_ParseTree <ParseTree> = productions:R_ProductionRule<0,,_> { new ParseTree(productions) }

R_ProductionRule <ProductionRule> = _ predecessor:R_Symbol _ "-->" _ successors:R_ISymbol<1,,_> _ ";" { new ProductionRule(predecessor, successors) }

R_TOperation <TOperation> = "t" _ "(" _ params:R_IMathExp<3, 3, _ "," _> _ ")" { new TOperation("t", @params.Cast<object>().ToList()) }

R_ROperation <ROperation> = "r" _ "(" _ params:R_IMathExp<3, 3, _ "," _> _ ")" _ { new ROperation("r", @params.Cast<object>().ToList()) }

R_SOperation <SOperation> = "s" _ "(" _ params:R_IMathExp<3, 3, _ "," _> _ ")" _ { new SOperation("s", @params.Cast<object>().ToList()) }

R_ExtrudeOperation <ShapeOperation> = "extrude" _ "(" _ params:R_IMathExp<1, 2, _ "," _> _ ")" _ { new ExtrudeOperation("extrude", @params.Cast<object>().ToList()) }

R_ComponentSplitOperation <ComponentSplitOperation> = "comp" _ "(" _ selector:R_ComponentSelector _ ")" _ "{" _ args:R_ComponentSplitArg<0,, _ "|" _> _ "}" { new ComponentSplitOperation("comp", new List<object>() { selector }.Union(args.Cast<object>()).ToList()) }

R_ComponentSplitArg <ComponentSplitArg> = selector:R_SemanticSelector _ (":" / "=") _ successor:R_ISymbol { new ComponentSplitArg(selector, successor) }

R_ComponentSelector <ComponentSelector> -memoize = value:("f"i / "e"i / "v"i) { (ComponentSelector)value.ToUpper()[0] }

R_SemanticSelector <SemanticSelector> -memoize = value:("front"i / "back"i / "left"i / "right"i / "top"i / "bottom"i / "vertical"i / "horizontal"i / "side"i / "all"i) { ParseEnum<SemanticSelector>(value) }

R_SplitOperation <SplitOperation> = "split" _ "(" _ params:R_SplitOperationParams _ ")" _ pattern:R_SplitPattern { new SplitOperation("split", @params.Union(new object[] { pattern }).ToList()) }

R_SplitOperationParams <IEnumerable<object>> = axis:R_Axis { new object[] { axis } } / axis:R_Axis _ "," _ adjust:R_AdjustSelector { new object[] { axis, adjust } }

R_AdjustSelector <AdjustSelector> -memoize = value:("adjust"i / "noadjust"i) { ParseEnum<AdjustSelector>(value) }

R_ISplitter <ISplitter> = R_SplitStep / R_SplitPattern

R_SplitPattern <SplitPattern> = "{" _ steps:R_ISplitter<0,, _ "|" _> _ "}" _ switch:"*"? { new SplitPattern(steps, @switch.Count > 0) }

R_SplitStep <SplitStep> = prefix:R_SizePrefix? _ value:R_IMathExp _ ":" _ successor:R_ISymbol { new SplitStep(prefix.Count == 0 ? (SizePrefix?)null : prefix[0], value, successor) }

R_SizePrefix <SizePrefix> -memoize = value:("~" / "'") { (SizePrefix)value.ToUpper()[0] }

R_ShapeOperation <ShapeOperation> = R_TOperation / R_ROperation / R_SOperation / R_ExtrudeOperation / R_ComponentSplitOperation / R_SplitOperation

R_Symbol <Symbol> = name:R_Identifier { new Symbol(name) }

R_ISymbol <ISymbol> = R_ShapeOperation / R_Symbol

R_AlgebraicOperationType <AlgebraicOperationType> -memoize = value:("+" / "-" / "*" / "/" / "^" / "%") { (AlgebraicOperationType)value[0] }

R_ConstMathExpValue <float> -memoize = value:R_Float / R_NIL { 0 } / value:R_Axis { (float)value }

R_IMathExp <IMathExp> -memoize = leftOperand:R_IMathExp _ type:R_AlgebraicOperationType _ rightOperand:R_IMathExp { new AlgebraicOperation(type, leftOperand, rightOperand) } / value:R_ConstMathExpValue { new ConstMathExp(value) } / "(" _ value:R_IMathExp _ ")" {{ value.Parenthesized = true; return value; }} / "-" _ value:R_IMathExp {{ value.Negated = true; return value; }}

R_Axis <Axis> = value:("x"i / "y"i / "z"i) { ParseEnum<Axis>(value) }

R_Identifier <string> -memoize = value: ([a-zA-Z]+) { string.Join("", value) }

R_NIL <object> -memoize = "nil"i { null }

R_Float <float> -memoize = value:([-]?[0-9]+("."[0-9]*)?) { float.Parse(value) }

_ -memoize = [ \t\r\n]*